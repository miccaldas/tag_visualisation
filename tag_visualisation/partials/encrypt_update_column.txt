    # Loads .env's variables to this module.
    load_dotenv()
    # Variables defined in the .env file at the top of the project tree.
    res_pth = os.getenv("PWD_SEC_LOC")
    enc_key = os.getenv("PWD_KEY_LOC")
    decinfo = os.environ.get("PWD_DECINFO_LOC")

    # Location of the Themis key.
    with open(
        f"{enc_key}",
        "rb",
    ) as g:
        sym_key = pickle.load(g)
        cell = SCellSeal(key=sym_key)

    decrypt_info = []
    # Sqlite3 prints callback on errors.
    sqlite3.enable_callback_tracebacks(True)
    conn = sqlite3.connect("pwd.db")
    cur = conn.cursor()
    query = "SELECT <COLUMN_NAME>, <COLUMN_NAME> FROM <DATABASE_NAME>"
    for row in cur.execute(
        query,
    ):
        # Taking in account the existence of
        # null values in the chosen column.
        if row[1] is None:
            # 'row' is a tuple, and tuples are immutable.
            # As we need to change the value of the column to
            # 'none', to avoid an error message, we need
            # to first convert it to a list, do the change,
            # and convert it back to tuple.
            lst = list(row)
            lst[1] = "null"
            row = tuple(lst)
            stri = row[1]
        if len(row[1]) > 1:
            stri = row[1]
        ints = row[0]
        # We are converting the old strings to encrypted
        # bytes objects. If there are already in the db
        # some entries with encrypted values, a error
        # message is produced. This 'if' clause avoids it.
        if type(stri) != bytes:
            btri = bytes(stri, "latin-1")
        else:
            btri = stri
        # Themis' decryption functions, consume
        # two separate information entities,
        # one supplied by the user, the other
        # generated by the encryption function:
        # 1. Context. Context is an optional value
        #    that somehow identifies and marks the
        #    encrypted entry. For example, in this
        #    case, the context used was the 'pwdid'
        #    value. Now, when decrypting, it'll
        #    that added bit of information to do the
        #    decrypting. Otherwise it produces an exception.
        # 2. Encrypted. Or any other name that you want
        #    to give to the variable that identifies Themis'
        #    encryption process.
        bval = ints.to_bytes(2, sys.byteorder)
        encrypted = cell.encrypt(btri, bval)
        decrypt_info.append((encrypted, bval))

    # This will be used by, 'update', 'search'...
    with open("decrypt_info.bin", "ab") as v:
        pickle.dump(decrypt_info, v)
    
    subprocess.run(f"mv decrypt_info.bin {res_pth}", shell=True)


@db_information
@snoop
def update_pwd():
    """
    Reads the list of tuples in 'decrypt_info.bin'
    and sends it to the datbase to update.
    """

    lst_in_lst = []
    with open(f"{decinfo}", "rb") as r:
        while True:
            try:
                lst_in_lst.append(pickle.load(r))
            except EOFError:
                break

    # 'decrypt_info.bin' is a list of tuples inside another
    # list. This comprehension flattens it out.
    lst = [i for sublst in lst_in_lst for i in sublst]
    sqlite3.enable_callback_tracebacks(True)
    conn = sqlite3.connect("<DATABASE>.db")
    for tup in lst:
        # There are two ways of ordering the most important
        # inside a bytes object, in the beginning or the end.
        # We need  this information as second argument of the
        # 'int.form_bytes' function. Using 'sys.byteorder'
        # tells it to use the ordering used by the system.
        id_int = int.from_bytes(tup[1], sys.byteorder)
        answers = [tup[0], id_int]
        query = "UPDATE pwd SET pwd = ?1 WHERE pwdid = ?2"
        conn.execute(query, answers)
        conn.commit()
    conn.close()

    return query
